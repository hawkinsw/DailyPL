There are a several formal ways that functional programming languages differ from imperative/object-oriented languages: (lack of) loops, the mechanism of evaluation, the (missing) ability to pass functions as parameters to other functions (and have them be returned by functions). Those distinctions obviously make a huge difference in how we write code in the different paradigms. However, there are other ways that the languages differ that, I would argue, are just as consequential: Their idioms.

In functional programming languages, pattern matching is an incredibly common paradigm. What's cool is that we don't have to wait to start learning functional programming languages to experience the joy of using this _new_ type of control flow operation!

Pattern matching is a way to encode conditional execution based on the _type_ of an expression rather than the _value_ of an expression. In most programming languages, two-way branching based on the value of an expression can be encoded using _if-then-else_ statements. In many languages, multiway branching based on the value of a variable can be encoded using _case_ statements.

With pattern matching, programmers can encode conditional execution depending on whether the type of a variable is, say, an integer or a float. On its face, that only seems reasonable in languages that are dynamically typed. In a statically typed language the type of a variable never changes at runtime so a program's control flow based on the type of a variable would be fixed at the time it is compiled. Right?

Remember, though, the union type. The union type gives statically typed languages the ability to declare variables whose type will change throughout execution -- as we said, union types are the secret tunnel that we can use to escape the type system's jail. The discriminated union (remember that?) contains a tag that can be used to determine the type of the variable being held in the union at any time during program execution. Of the different types that a union-typed variable can hold during program execution, there is only one that is _active_ at any given time.

Again, pattern matching is common in functional programming languages (like Haskell -- more on this in the module on functional programming) and forms a large part of newer languages (like Rust). It is a feature whose behavior can be duplicated in object-oriented programming paradigms using virtual dispatch (more on that in the next module). However, many language designers are beginning to realize the power of pattern matching and adding it to [existing languages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2392r0.pdf). Python is one of those languages.

To make understanding the syntax of pattern matching in Python easier, we will have to take a short, minor, detour through destructuring.

### Destructuring

Destructuring is a syntactic shorthand for breaking apart composite types (really, anything that can be iterated) into their component parts. We are using the term destructuring here because that is the term used by the programming languages community and other languages (like [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)) to describe functionality like we are about to explore. However, each language that offers such functionality has a different term. In Python it is called [sequence unpacking.](https://peps.python.org/pep-3132/)

Python has a [_tuple_](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences) composite type and values are generated by enclosing comma-separated lists in `()`s. For instance,

```Python
t = (a, b)
```

assigns `t` a tuple (in this case a pair) of values `a` and `b`, where `a` and `b` are variables.

In Python you can treat tuples like lists. So, you could access the first element of the tuple like `t[0]` and the second like `t[1]`. To set `aa` to `a` (via `t`) and `bb` to `b` (via `t`) you could do

```Python
aa = t[0]  
bb = t[1]
```

But that's a lot of typing. Instead, try a destructuring assignment to accomplish the same thing:

```Python
aa, bb = t
```

> Note: Some people refer to these operations as parallel or simultaneous assignment.

Lists are another common composite data type in Python. Believe it or not, you've already seen some destructuring techniques for lists available in Python. Remember

```Python
head, *tail = [1, 2, 3, 4, 5]
```

from PL After Dark - Types? That's destructuring, too!

And what if we only want certain elements from that list and not all of them? To get the first and the last elements,

```Python
first, *_, last = [1, 2, 3, 4, 5]
```

In a destructuring, the `*` means multiple elements and the `_` means _I don't care about that value and don't want to waste a variable on it_.

To see destructuring in action, look at [https://github.com/hawkinsw/cs3003/blob/main/pattern_matching/destruct.py](https://github.com/hawkinsw/cs3003/blob/main/pattern_matching/destruct.py).

### Instances

Perhaps you are not yet convinced that pattern matching is something you will want to use on a regular basis. That's fine! We'll look at some functionality in Python that you have probably already used before and see how pattern matching would make it easier to write!

Python has a builtin function called [`isinstance`](https://docs.python.org/3/library/functions.html#isinstance). `isinstance` takes two parameters -- a variable and a type/class. It returns `True` if the variable is an instance of the type/class and `False` otherwise. For example


```Python
class Addition(object):
  def __init__(self, left, right):
    self.left = left
    self.right = right
  def __repr__(self):
    return "Addition"

class Subtraction(object):
  def __init__(self, left, right):
    self.left = left
    self.right = right
  def __repr__(self):
    return "Subtraction"

class Multiplication(object):
  def __init__(self, left, right):
    self.left = left
    self.right = right
  def __repr__(self):
    return "Multiplication"

if __name__=='__main__':
  add = Addition(5, 4)

  if isinstance(add, Addition):
    print("add is an Addition object!")
  if not isinstance(add, Subtraction):
    print("add is not a Subtraction object!")
```

prints

```console
add is an Addition object!  
add is not a Subtraction object!
```

So, let's write a function that takes either an `Addition` or a `Subtraction`, calculates the result, and returns its value! We will define the function to take the operation as a parameter:

```Python
def exec(operation):
  pass
```
We can use `isinstance` to determine whether `operation` is an `Addition` or a `Subtraction` type:

```Python
def exec(operation):
  if isinstance(operation, Addition):
    print(f"Does this print Addition? {operation}")
    pass
  elif isinstance(operation, Subtraction):
    print(f"Does this print Subtraction? {operation}")
    pass
  else:
    raise SyntaxError(f"exec cannot handle an {operation}.")
```
Now, let's call `exec` and see what we get:

```Python
if __name__=='__main__':
  add = Addition(5, 4)
  subtract = Subtraction(5, 4)
  multiply = Multiplication(5, 4)
  exec(add)
  exec(subtract)
  exec(multiply)
```

This code will print

```console
Does this print Addition? Addition  
Does this print Subtraction? Subtraction  
Traceback (most recent call last):  
  File "exec.py", line 39, in <module>  
    exec(multiply)  
  File "exec.py", line 31, in exec  
    raise SyntaxError(f"exec cannot handle an {operation}.")  
SyntaxError: exec cannot handle an Multiplication.
```

Exactly what we expected. The instance of the `Multiplication` type passed to the `exec` function falls into the `else` because the variable is neither an `Addition` nor a `Subtraction`.

Now, let's make the `exec` function do something:

```Python
def exec(operation):
  if isinstance(operation, Addition):
    return operation.left + operation.right
  elif isinstance(operation, Subtraction):
    return operation.left - operation.right
    pass
  else:
    raise SyntaxError(f"exec cannot handle an {operation}.")
```

And we'll test:

```Python
if __name__=='__main__':
  add = Addition(5, 4)
  subtract = Subtraction(5, 4)
  multiply = Multiplication(5, 4)
  print(f"exec(add): {exec(add)}")
  print(f"exec(subtract): {exec(subtract)}")
  print(f"exec(multiply): {exec(multiply)}")
```

This code prints

```console
exec(add): 9  
exec(subtract): 1  
Traceback (most recent call last):  
  File "exec.py", line 38, in <module>  
    print(f"exec(multiply): {exec(multiply)}")  
  File "exec.py", line 30, in exec  
    raise SyntaxError(f"exec cannot handle an {operation}.")  
SyntaxError: exec cannot handle an Multiplication.
```

Wow. We did it! We have a function that takes a parameter and works differently depending on the _type_ of that parameter! Pretty cool! You can play with the actual code online at [https://github.com/hawkinsw/cs3003/blob/main/pattern_matching/exec.py](https://github.com/hawkinsw/cs3003/blob/main/pattern_matching/exec.py).

### Pattern Matching

If only there were a syntax that would make that, well, easier! The Batman of Pattern matching (and his Robin destructuring) come to the rescue! Assuming the same class definitions of `Addition`, `Subtraction` and `Multiplication` as above, we could rewrite `exec` like this:

```Python
def exec(operation):
  match operation:
    case Addition(left = local_left, right = local_right):
      print(f"Adding {local_left} to {local_right}")
    case Subtraction(left = local_left, right = local_right):
      print(f"Subtracting {local_right} from {local_left}")
    case _:
      raise SyntaxError(f"exec cannot handle a {operation}")
```

Before we figure out what this prints, let's digest the syntax. You will notice that it looks very similar to a [`switch`](https://en.cppreference.com/w/cpp/language/switch) statement in C++, doesn't it? The `match` keyword is paired with the name of a variable -- here, `operation`. This combination is telling Python that we are going to pattern match on the _type_ of the `operation` variable. The `case` keyword is paired with something that looks very much like a constructor for an instance of an `Addition` or `Subtraction` class. This combination is like the `isinstance` that we used above. The list of assignments in the parenthesis of those constructor-like things are doing destructuring. On the left-hand side of the equal is the name of an attribute of the type -- here, `Addition` and `Subtraction`. On the right-hand side is a variable that we can use locally which is assigned to the value of that attribute in the matched variable. In other words, it would be approximately equivalent to

```Python
local_left = operation.left
```

We do the same thing for the right-hand side. 

That description is a mouthful, I know. However, it'll make sense when we see it in action:

```Python
if __name__=='__main__':
  add = Addition(5, 4)
  subtract = Subtraction(5, 4)
  multiply = Multiplication(5, 4)
  exec(add)
  exec(subtract)
  exec(multiply)
```

The `add` object has two attributes, `left` and `right`. We could access those attributes as `add.left` and `add.right`. `add.left` is `5` and `add.right` is `4`. During the execution of `exec` where `add` is the parameter,

```Python
case Addition(left = local_left, right = local_right):
```

matches and the local values `local_left` and `local_right` contain the values 5 and 4, respectively. The above code in its entirety prints

```console
Adding 5 to 4
Subtracting 4 from 5
Traceback (most recent call last):
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern.py", line 38, in <module>
    exec(multiply)
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern.py", line 30, in exec
    raise SyntaxError(f"exec cannot handle a {operation}")
SyntaxError: exec cannot handle a Multiplication
```

Pretty cool!

Now, let's restore the actual execution operation:

```Python
def exec(operation):
  match operation:
    case Addition(left = local_left, right = local_right):
      return local_left + local_right
    case Subtraction(left = local_left, right = local_right):
      return local_left - local_right
    case _:
      raise SyntaxError("exec cannot handle a {operation}")
```

Let's try it out:

```Python
if __name__=='__main__':
  add = Addition(5, 4)
  subtract = Subtraction(5, 4)
  multiply = Multiplication(5, 4)
  print(f"exec(add): {exec(add)}")
  print(f"exec(subtract): {exec(subtract)}")
  print(f"exec(multiply): {exec(multiply)}")
```

This code prints:

```console
exec(add): 9  
exec(subtract): 1  
Traceback (most recent call last):  
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern.py", line 38, in <module>  
    print(f"exec(multiply): {exec(multiply)}")  
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern.py", line 30, in exec  
    raise SyntaxError(f"exec cannot handle a {operation}")  
SyntaxError: exec cannot handle a Multiplication
```

Now _that_ is pretty cool!

We'll leave the implementation of the functionality of exec function for `Multiplication` up to you. But, let's work together on `Division`! The change is pretty straightforward. We'll just follow the pattern (get it?) that we have established with `Addition` and `Subtraction`:

```Python
def exec(operation):
  match operation:
    case Addition(left = local_left, right = local_right):
      return local_left + local_right
    case Subtraction(left = local_left, right = local_right):
      return local_left - local_right
    case Division(left = local_left, right = local_right):
      return local_left / local_right
    case _:
      raise SyntaxError(f"exec cannot handle a {operation}")
```

Then we can add a use of the `Division` operation to try it out:

```Python
if __name__=='__main__':
  add = Addition(5, 4)
  subtract = Subtraction(5, 4)
  divide = Division(5, 4)
  multiply = Multiplication(5, 4)
  print(f"exec(add): {exec(add)}")
  print(f"exec(subtract): {exec(subtract)}")
  print(f"exec(divide): {exec(divide)}")
  print(f"exec(multiply): {exec(multiply)}")
```

Let's see what happens:

```console
exec(add): 9
exec(subtract): 1
exec(divide): 1.25
Traceback (most recent call last):
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern-plus.py", line 49, in <module>
    print(f"exec(multiply): {exec(multiply)}")
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern-plus.py", line 39, in exec
    raise SyntaxError(f"exec cannot handle a {operation}")
SyntaxError: exec cannot handle a Multiplication
```

Neat!

Let's try another:

```Python
if __name__=='__main__':
  add = Addition(5, 4)
  subtract = Subtraction(5, 4)
  divide = Division(5, 0)
  multiply = Multiplication(5, 4)
  print(f"exec(add): {exec(add)}")
  print(f"exec(subtract): {exec(subtract)}")
  print(f"exec(divide): {exec(divide)}")
  print(f"exec(multiply): {exec(multiply)}")
```

And:

```
exec(add): 9
exec(subtract): 1
Traceback (most recent call last):
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern-plus.py", line 48, in <module>
    print(f"exec(divide): {exec(divide)}")
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern-plus.py", line 37, in exec
    return left / right
ZeroDivisionError: division by zero
```

Hrmph! Obviously Python is no miracle worker and we are being silly for thinking that it can divide by `0`! Instead of having our application crash when the user attempts to divide by `0`, let's instead print out a warning and simply have the operation evaluate to `0`:

```Python
def exec(operation):
  match operation:
    case Addition(left = local_left, right = local_right):
      return local_left + local_right
    case Subtraction(left = local_left, right = local_right):
      return local_left - local_right
    case Division(left = local_left, right = local_right):
      if local_right == 0:
        print("Warning: Attempt to divide by zero. " +
          "Cowardly refusing and returning 0 instead.")
        return 0
      return local_left / local_right
    case _: 
      raise SyntaxError(f"exec cannot handle a {operation}")
```

Does it work? Let's rerun the same example from earlier and see the result:

```console
exec(add): 9
exec(subtract): 1
Warning: Attempt to divide by zero. Cowardly refusing and returning 0 instead.
exec(divide): 0
Traceback (most recent call last):
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern-plus.py", line 53, in <module>
    print(f"exec(multiply): {exec(multiply)}")
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern-plus.py", line 43, in exec
    raise SyntaxError(f"exec cannot handle a {operation}")
SyntaxError: exec cannot handle a Multiplication
```

Perfect!

Well, not quite. I _hate_ `if` statements. And, once I learned about pattern matching, I began to hate `if` statements even more! So, can we get rid of the `if` statement in the `Division` case altogether? Well, what if (pun intended) there were a way to have a pattern match according to the type of the variable _and_ the value of one of its elements? Amazingly enough, Python allows us just this power:

```Python
def exec(operation):
  match operation:
    case Addition(left = local_left, right = local_right):
      return local_left + local_right
    case Subtraction(left = local_left, right = local_right):
      return local_left - local_right
    case Division(left = local_left, local_right = 0):
      print("Warning: Attempt to divide by zero. " +
        "Cowardly refusing and returning 0 instead.")
      return 0 
    case Division(left = local_left, right = local_right):
      return local_left / local_right
    case _: 
      raise SyntaxError(f"exec cannot handle a {operation}")
```

Python attempts to match from top to bottom. So, when matching an `operation` whose type is `Division`, the first two cases are not matched and Python encounters the first of the two `Division` cases. Then, Python confirms the match left to right. Well, the type does match -- `operation` is a `Division`. Next Python sees `left = local_left`. That is a so-called [irrefutable pattern](https://doc.rust-lang.org/book/ch18-02-refutability.html), one that _always_ matches. Why does it always match? Because it is not really a match at all. It is just pulling out the `left` attribute of `operation` and assigning it to a local variable named `local_left`. Cool! So, finally, Python sees `right = 0`. Because the `right` attribute of `operation` is, in this case, `0`, the match succeeds and the associated block of code is executed:

```console
exec(add): 9
exec(subtract): 1
Warning: Attempt to divide by zero. Cowardly refusing and returning 0 instead.
exec(divide): 0
Traceback (most recent call last):
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern-plus.py", line 53, in <module>
    print(f"exec(multiply): {exec(multiply)}")
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern-plus.py", line 43, in exec
    raise SyntaxError(f"exec cannot handle a {operation}")
SyntaxError: exec cannot handle a Multiplication
```

Let's check to make sure that our code still works when things are nominal (I love that term!):

```Python
if __name__=='__main__':
  add = Addition(5, 4)
  subtract = Subtraction(5, 4)
  divide = Division(5, 1)
  multiply = Multiplication(5, 4)
  print(f"exec(add): {exec(add)}")
  print(f"exec(subtract): {exec(subtract)}")
  print(f"exec(divide): {exec(divide)}")
  print(f"exec(multiply): {exec(multiply)}")
```

Let's walk through this code! As before, the first two cases are not matched and Python encounters the first of the two `Division` cases. Let's go right to left again. The type does match -- operation is a `Division`. Next Python sees `left = local_left`, the irrefutable pattern, and proceeds. Now Python makes contact with the `right = 0`. Because the `right` attribute of `operation` is, in this case, _not_ `0`, the match fails. Python moves on to the next case which contains only irrefutable patterns, the match succeeds and the associated block of code is executed:

```console
exec(add): 9
exec(subtract): 1
exec(divide): 5.0
Traceback (most recent call last):
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern-plus.py", line 53, in <module>
    print(f"exec(multiply): {exec(multiply)}")
  File "/home/hawkinsw/code/uc/cs3003/pattern_matching/pattern-plus.py", line 43, in exec
    raise SyntaxError(f"exec cannot handle a {operation}")
SyntaxError: exec cannot handle a Multiplication
```

### Conclusion

Now that you've learned about pattern matching in Python, try it for yourself: Download [https://github.com/hawkinsw/cs3003/blob/main/pattern_matching/pattern.py](https://github.com/hawkinsw/cs3003/blob/main/pattern_matching/pattern.py) and implement the `Multiplication` operation.

Be careful, though: In order for this code to run, you will need version 3.10 or later of Python!

For more information, you can read the official tutorial of pattern matching syntax [here](https://www.python.org/dev/peps/pep-0636/). You can also watch an introductory video about it [here](https://www.youtube.com/watch?v=NYUXNRswe6k).