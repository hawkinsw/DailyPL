### What's News


### How Do You Stack Up?

In this issue of the Daily PL, although we will recap the concepts related to the runtime stack ... we will focus on the code a compiler generates -- we will work with the C programming language -- that manipulates the stack and dissect how that code actually works. We are going to really dig into the details and relate our conceptual understanding of the runtime stack with the technical details. In our description of the code generated by the compiler, you may be unfamiliar with the syntax if you have never seen machine code before. Don't worry! I will explain the purpose of each instruction in a way that (I hope!) makes it possible for you to make sense of the code.

Before going forward, be sure to page into memory (pun definitely intended) the concepts and vocabulary that we learned in our conceptual discussion of the runtime stack: _prologue_, _epilogue_, and _invariants_ (the general meaning of the term and the invariants that apply in this context).

One final note: The perspective of "we" will shift throughout our exploration. At various points, "we" will be the function calling another function. At other times, "we" will be the function that is being called.

### It's Subjective
Subprograms are the lifeblood of our programs. They are a fundamental tool for designing software that is reusable and maintainable. Even if we are writing software in languages that fit the object-oriented, functional or logic paradigm, we use subprograms to package up functionality so that other programmers can reuse it. What's more, subprograms _hide_ the details of how a particular task is accomplished. In other words, they provide a means of _process abstraction_!

A program built on an architecture of process abstraction with subprograms will consist of a series of invocations of those subprograms. The code that we write for our programs is (almost) always contained in subprograms. Those subprograms call other subprograms which, in turn, call subprograms. When a subprogram completes its task, it must return control back to the function that called it (along with the result of any calculation, if it is a function). That subprogram then resumes execution.

 Let's say that we are calling a function that has two parameters (which are numbers), adds them together, and returns the result. Let's be creative, and say that the function is named `add`. Woah -- crazy, I know!

```C++

int add(int a, int b) {
    int result = a + b;
    return result;
}
```

Let's also say that we have a function that has a single parameter and multiplies its argument by two and returns the result:

```C++

int multiply_by_two(int a) {
    int multiplied = a * 2;
    return multiplied;
}
```

Let's get wild and crazy and use these two functions to calculate $5 + 2*5$:

```C++
int main() {
    int five = 5;
    int five_times_two = multiply_by_two(five);
    int sum = add(five, five_times_two);
    return 0;
}
```

### Get Fired Up

Because subprograms hide details, programming languages allow for a complete firewall between code that invokes a subprogram and the code of the subprogram being called.

_As a caller of `multiply_by_two`_, **we** want to (metaphorically) put the value for `multiply_by_two`'s parameter (its called the _argument_, remember!) into an envelope, drop it in one of those awesome blue mailboxes and then wait patiently at our door for the result to come back!

If that is the only way in which we interact with `multiply_by_two`, then there is absolutely no way to break the abstraction provided by the subprogram. Our visibility into the _how_ of `multiply_by_two` is completely obscured. What's more, `multiply_by_two` can't see us, either. We can only communicate with one another through envelopes.

And, if you know anything about the USPS, you know that mailing a letter is not exactly instantaneous. So, when our argument-laden mailing arrives at `multiply_by_two`, `multiply_by_two` better know exactly what to do with it. 

Although the USPS is one of the best things provided to US citizens by the government, it is not magic. An envelope that we mail must be labeled with the address of the recepient. Otherwise, there's no chance it will arrive at its destination.

Filling an envelope with the arguments, labelling the envelope and dropping it in the mailbox are all pieces of the prologue. In particular, they are all parts of the prologue that is the responsibility of the code calling another subprogram. 

Why can't this piece of the prologue be done by the function being called? Because we (again, "we" are the caller!) are the only ones who know the value we want multiplied. The code in the `multiply_by_two` function must be generic enough in order to double _any_ number that a programmer who calls the function specifies. The writer of `multiply_by_two` cannot make any assumptions about the values that its users want to manipulate (other than the fact that the values specified are actually, you know, numbers).

Now, how does that translate into code?

### Does Anyone Lick Stamps Anymore?

Here is a slightly annotated version of our `main` function:

```C++
int main() {
    int five = 5;
    int five_times_two = /* HANDOFF */ multiply_by_two(five);
    int sum = add(five, five_times_two);
    return 0;
}
```
The point marked `HANDOFF` is where we make our visit to the post office. And here is the code that a C compiler generates that goes in that spot:


```asm
push   -0xc(%ebp)
call   11ad
```

I know, right? Where's the rest of the code? There is so much happening in those two lines.

### Invariable 